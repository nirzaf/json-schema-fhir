'use strict';

const store = require('@graphql-mesh/store');
const jsonSchema = require('@omnigraph/json-schema');
const utils = require('@graphql-mesh/utils');
const stringInterpolation = require('@graphql-mesh/string-interpolation');
const crossHelpers = require('@graphql-mesh/cross-helpers');

class JsonSchemaHandler {
    constructor({ name, config, baseDir, store: store$1, pubsub, logger, importFn, }) {
        this.name = name;
        this.config = config;
        this.baseDir = baseDir;
        this.importFn = importFn;
        this.bundleStoreProxy = store$1.proxy('jsonSchemaBundle', store.PredefinedProxyOptions.JsonWithoutValidation);
        this.pubsub = pubsub;
        this.logger = logger;
    }
    async getDereferencedBundle() {
        const config = this.config;
        if ('bundlePath' in config) {
            const headersFactory = stringInterpolation.getInterpolatedHeadersFactory(config.bundleHeaders);
            const bundle = await utils.readFileOrUrl(config.bundlePath, {
                cwd: this.baseDir,
                fetch: this.fetchFn,
                logger: this.logger,
                headers: headersFactory({
                    env: crossHelpers.process.env,
                }),
                fallbackFormat: 'json',
                importFn: this.importFn,
            });
            return bundle;
        }
        else {
            return this.bundleStoreProxy.getWithSet(() => {
                return jsonSchema.createBundle(this.name, {
                    ...config,
                    operations: config.operations,
                    cwd: this.baseDir,
                    fetch: this.fetchFn,
                    logger: this.logger,
                    operationHeaders: typeof config.operationHeaders === 'string' ? {} : config.operationHeaders,
                });
            });
        }
    }
    async getMeshSource({ fetchFn }) {
        this.fetchFn = fetchFn;
        const bundle = await this.getDereferencedBundle();
        const operationHeadersConfig = typeof this.config.operationHeaders === 'string'
            ? await utils.loadFromModuleExportExpression(this.config.operationHeaders, {
                cwd: this.baseDir,
                importFn: this.importFn,
                defaultExportName: 'default',
            })
            : this.config.operationHeaders;
        const schema = await jsonSchema.getGraphQLSchemaFromBundle(bundle, {
            cwd: this.baseDir,
            fetch: this.fetchFn,
            pubsub: this.pubsub,
            logger: this.logger,
            baseUrl: this.config.baseUrl,
            operationHeaders: operationHeadersConfig,
            queryStringOptions: this.config.queryStringOptions,
        });
        return {
            schema,
        };
    }
}

module.exports = JsonSchemaHandler;
